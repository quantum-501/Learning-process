1. 防抖与节流（https://juejin.cn/post/6844903795420299278#chapter-three）
2. 判断一个js对象（arr）是否是Array，最准确的方法：Object.prototype.toString.call(arr) === '[object Array]'
3. instanceof 是为了测试原型链元素是否存在
4. arr.filter()用于筛选出满足要求的数组元素，并返回新的数组，因此输出结果为[20,12]；.some()用于检测数组是否有满足条件的元素，只要元素满足要求返回true，否则false；.every()检测数组
   所有元素是否都满足条件，是返回true，否返回false；.map()会对数组中每个元素进行单独判断，返回true或false，作为新数组的元素，输出结果为[false, true, false, true, false]
   （https://blog.csdn.net/weixin_43814020/article/details/106678432）
5. js变量提升的机制，变量声明优先于变量赋值 var carname="Volvo";var carname; IS EQUAL TO var carname; var carname; // 覆盖了第一个carname  carname="Volvo" 
6. promise遇到receive或reject情况，大多数情况下，回调函数then: 分别向doneList和failList中添加回调函数； always: 添加一个无论成功还是失败都会调用的回调函数
7. var x=y===true?”true”:”false”; ===表示同一类型变量的比较，将比较结果给x赋值； 赋值操作符（=）优先级小于三元操作符的优先级
8. event loop和 callback queue ： https://www.ruanyifeng.com/blog/2014/10/event-loop.html
9. let obj = { num1: 117 };let res = obj; obj.child = obj = { num2: 935 }连等赋值符（赋值操作先定义变量(从左到右)，再进行赋值（从右到左))
10. {} == {} ？为false，引用值的地址都不同,==值相同而数据类型不相同
11. dom2规定的事件流包括3个阶段：①事件捕获，②处于目标阶段（事件处理 ），③事件冒泡阶段。
12. hasOwnProperty：是用来判断一个对象是否有你给出名称的属性或对象。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。
13. in：会向原型链上查找; hasOwnProperty：属性是否在对象上，不从原型链上查找
14. 操作符之间优先级(高到低):算数 → 比较 → 布尔(逻辑)(逻辑与(&&)优先级高于逻辑或(||))→ “=”赋值符号; 判断 var a = 4 >= 6 || true && 1 || false；1）4 >= 6；2）true && 1
    原式变为 false || 1 || false（按正常顺序执行）3)false||1，结果是1（逻辑或的规则：第一个操作数是假值，则返回第二个操作数）4）1||false，结果1（逻辑:首个操符是真,返回首个操符）
15. 在jsx中，class是js关键字，要用classname代替class<div class=”msg-box”>{msg}</div>；直接写行内样式<style={{height: 50}}>时不能采用引号，而是style={{color:'red'}}的方式。
16. parseInt(string,raix)有两个参数//注意:string字符串只会被解析从第一个字符开始直到不是数字的字符部分;console.log(parseInt('22e3'))//22//当字符串中间存在非数字,就只解析前面数字的部分字符;
17. 不可事件冒泡:load,unload,abort(音频综止）resize，error，mouseenter，mouseleave,blur,focus,
18. 1 in [1]并不是表示数字1在不在数组里。而是表示数组中含不含有1这个索引index值;in操作符，对于数组属性需要指定数字形式的索引值来表示数组的属性名称表示1
19. 1&&2>1. 先判断2>1再判断&&
20. <button>点击</button> <script> var btn = document.querySelector('button');</script>执行以下程序,要求当用户点击按钮1秒后禁用按钮,以下选项的做法,不符合要求的()
    A.btn.onclick = function(){ var that = this; setTimeout(function(){that.disabled = true;},1000) }
    B.btn.onclick = function(){ setTimeout(function(){this.disabled = true;},1000) }
    C.btn.onclick = function(){ setTimeout(()=>{  this.disabled = true; },1000) }
    D.btn.onclick = function(){ setTimeout(function(){this.disabled = true;}.bind(this),1000) }
    B选项，在定时器中，this指向window对象，而不是btn对象。而在定时器的同级作用域，this指代btn对象，ACD选项均是在定时器函数中使用该btn对象。
21. 使用new Function()创建函数对象时，其参数必须为字符串形式。
22. <div id=”info” style=”display:block”><p> 请填写 </p></div>
    document.innerHTML: 也就是从对象的起始位置到终止位置的全部内容,包括Html标签。上例中的test.innerHTML的值也就是“<span style="color:red">test1</span> test2 ”。
    document.innerText:从起始位置到终止位置的内容, 但它去除Html标签;上例中的text.innerTest的值也就是“test1 test2”, 其中span标签去除了。
    doc.outerHTML:除了包含innerHTML的全部内容外, 还包含对象标签本身;上例中的text.outerHTML的值也就是<div id="test"><span style="color:red">test1</span> test2</div>
23. 1 in Object(1.0).constructor; //false;  Number[1] = 123; 1 in Object(1.0).constructor; //true  因为number在object原型链上
24. continue语句只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内，在其它地方使用都会引起错误！是停止当前语句，并从头执行该语句
    break的意思是跳出循环，也就是循环结束。
25.构造函数继承是每次继承都会把父类的所有属性方法全部拷贝一份，而对于公用的方法重复拷贝会浪费内存; 原型链继承所有对象都公用一份原型属性和方法，对一个类的修改回影响的其他类
   组合继承是结合两种继承方式，用构造函数方式继承属性，原型链方式继承方法 https://www.cnblogs.com/Leophen/p/11401734.html
26. AMD(推崇依赖前置)是 RequireJS 在推广过程中对模块定义的规范化产出，而CMD(依赖就近)是 SeaJS 在推广过程中对模块定义的规范化产出;
27. enum TYPE { OK, YES } // ts 有enum直接用 js先定义空对象再添加 & 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化
28. append(content)方法. 作用：向每个匹配的元素内部追加内容. 参数介绍：content (<Content>): 要追加到目标中的内容。
    appendTo(expr)方法. 作用：把所有匹配的元素追加到指定的元素元素集合中 参数介绍：expr (String): 用于匹配元素的jQuery表达式;append是大放小; appendtto是小放大
29. arr instanceof array; //false || 只有实例对象(var x=new A().do();)上不存在的属性和方法才会去原型上查找
30. NaA与任何不相等，测试返回的不是true或false的值 ｜｜ +作为一元运算符时，会将参数转换为数字返回，eg: +new Array(017) return NaN
31. for in循环是遍历对象上的每一个可枚举属性,包括原型链上面的可枚举属性,
32. obeject.keys()只是遍历自身的可枚举属性,不可以遍历原型链上的可枚举属性
33. console.log(undefined + 1);undefined+1的结果为NaN，而不是undefined;
34. 函数如果没有return语句，则默认return undefined；在严格模式下，函数不允许重名参数；
35. Browser 对象 有关的对象: history screen location Navigator
36. document.getElementById(“id”).setAttribute(“disabled”,”true”);document.getElementById(“id”).disabled=true;表示某属性id的html元素被禁用了
37. js常见的继承方式原型链继承、借用构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承，以及ES6新增的class继承，但不包括关联继承
38. 正则表达式exec()用于检索字符串中的正则表达式的匹配,匹配到返回正则，不到就是null,并且和match一样只匹配一次；test()方法返回是boolean类型
39. isNaN(1/0)返回的是false。但是isNaN(0/0)返回的就是true
40. 引用数据类型：存储在堆中的对象，存储在栈中的值是一个指针，指向 存储对象的内存地址， object属于引用数据类型,修改objecy内部属性不会改变数值
41. Xml一般用于传输和存储数据，是对html的补充，两者的目的不同；在JavaScript里解析和处理xml数据时，因为浏览器的不同，其做法也不同；在IE浏览器里处理xml，首先需要创建ActiveXObject对象
42.  for (i = 0; i < 3; i++) {      num[i] = function () {  //这代码相当于num.push(function(){console.log(i)}),会改变原数组
     console.log(i)} 上面代码函数function(){console.log(i)}没有被调用，此函数内部的代码不会被执行 
     } 如果函数里面没返回值，那么会返回一个函数
43.typeof的结果只有基本数据类型 number string boolean undefined object function  不会有float
44.与Browser有关的对象: history screen location Navigator
45.Javascript和css没有display:visible属性和display:hidden属性；
46.JavaScript是专门为与网页交互而设计的,由三个不同的部分组成:ECMAScript核心语言功能,DOM(文档对象模型)访问和操作网页内容的方法和接口;BOM(浏览器对象模型)与浏览器交互的方法和接口
47.函数提升优先级高于变量提升，且不会被同名变量声明覆盖，但是会被变量赋值后覆盖
48.get和post方法传递参数: get有长度限制并且会出现页面参数泄露在地址栏中的情况; url中参数用&连接
49.arrary.forEach(a,b)是循环遍历数组，虽然函数内部存在return语句，但当执行return时会退出一次迭代，然后继续下一次元素迭代，a为数组元素值，b为数组元素对应索引
50. 1&&2运算，如果前值为true,则结果为后值。如果前值为false,则值为前值;1||2运算，如果前值为true,则结果为前值,如果前值为false,则结果为后值。
